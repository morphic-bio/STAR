PACKED READ INFO MIGRATION RUNBOOK
==================================

Stage 0 – Preflight
-------------------
0.1 Run `git status` and confirm you are on branch `design/packed-readinfo-8byte` (or the working branch requested).
0.2 Export `STAR_BUILD_DIR=/mnt/pikachu/STAR` (adjust if repo root differs) so path references below resolve.
0.3 Ensure the tree builds without the packed flag: `make clean && make STAR`.
0.4 Copy the baseline outputs you will diff against later:
    - `cp Aligned.out.bam legacy.Aligned.out.bam`
    - `cp -r Solo.out legacy.Solo.out` (or the specific `*.bin` files of interest).

Stage 1 – Shared Helper & Header Wiring
--------------------------------------
1.1 Open `source/SoloFeature.h`.
    - Under `#ifdef SOLO_USE_PACKED_READINFO`, add a forward declaration for `void recordReadInfo(uint32_t readId, uint32_t cbIdx, uint32_t umiPacked, uint8_t status);`.
    - Add `uint32_t getPackedCB(uint32_t readId) const;`, `uint32_t getPackedUMI(uint32_t readId) const;`, and `uint8_t getPackedStatus(uint32_t readId) const;` helpers next to the packed member so velocyto and other modules have a uniform accessor.
    - Declare a private inline helper `void resetPackedStorage(uint32_t nReads);` that will init either legacy or packed containers.

1.2 Create the helper implementations in `source/SoloFeature.cpp` (or the most appropriate implementation file if different):
    - Implement `resetPackedStorage` with `#ifdef SOLO_USE_PACKED_READINFO` calling `packedReadInfo.init(...)` and the legacy branch resizing `readInfo`.
    - Implement `recordReadInfo` with compile-time branches: set packed data via `.set()`/`.setStatus()` and legacy via struct writes.
    - Implement the `getPacked*` accessors; in the legacy branch they should read from `readInfo` for compatibility.

Stage 2 – Initialization Call Sites
-----------------------------------
2.1 Edit `source/SoloFeature_countCBgeneUMI.cpp`:
    - Replace the unconditional `readInfo.resize(...)` block with a call to `resetPackedStorage(nReadsInput)`.
    - Ensure log messages remain accurate (print whether packed or legacy was initialised).

2.2 Edit `source/SoloFeature_prepareReadInfoOnly.cpp`:
    - Replace `readInfo.resize(...)` with `resetPackedStorage(nReadsInput)`.
    - When iterating to populate values, swap any direct `readInfo[...]` writes for `recordReadInfo(...)`.

2.3 Review any other file initialising `readInfo` (search for `readInfo.resize(`) and switch them to `resetPackedStorage`.

Stage 3 – Collapse Paths & Status Handling
------------------------------------------
3.1 Edit `source/SoloFeature_collapseUMIall.cpp`:
    - Near the top of the file, add an inline lambda or static helper to pack decode-to-string logic if needed.
    - Replace every `if (readInfo.size()>0)` guard with compile-time `#ifdef SOLO_USE_PACKED_READINFO` using the new helper APIs.
    - Where UMIs are corrected (`umiCorrected`), call `recordReadInfo(iread1, cbIndex, correctedUMI, status)` and ensure `status` reflects the final state (1=valid, 2=invalid UMI, 0=missing CB).
    - Ensure multi-gene filtering updates call `setStatus` (status ≥2) so downstream consumers know UB should be blank.

3.2 Edit `source/SoloFeature_collapseUMI_Graph.cpp`, `source/SoloFeature_collapseUMIall.cpp`, and related helpers for any residual direct `readInfo[...]` writes.

Stage 4 – Downstream Consumers
------------------------------
4.1 Edit `source/SoloFeature_countVelocyto.cpp`:
    - Replace `soloFeatAll[...]->readInfo[iread]` accesses with the accessor trio (`getPackedCB/UMI/Status`).
    - Update the missing-data check to use `status != 1` instead of sentinel comparisons.

4.2 Audit other modules (`rg --no-heading "->readInfo" source`) and patch them to call the helper accessors.

Stage 5 – BAM/Tag Writers
-------------------------
5.1 Edit `source/SoloFeature_addBAMtags.cpp`:
    - Swap the string reconstruction to use the shared accessor; ensure only `status == 1` emits CB/UB tags.
    - Remove duplicated decode code if the helper centralises it.

5.2 Edit `source/BAMTagBuffer.cpp` (`writeTagBinaryPacked`):
    - After retrieving `cb`, increment by one before writing so the sentinel matches the legacy writer.
    - Pass the full status when header versioning allows; otherwise map `status != 1` to zero as today.

5.3 If not already present, bump the binary writer header version or add a TODO explaining the plan when multi-bit status support ships.

Stage 6 – PackedReadInfo Guards
-------------------------------
6.1 Edit `source/PackedReadInfo.cpp`:
    - In `init`, allow `umiLength == 0` by setting `umiBits = 0` and short-circuiting the mask helpers.
    - Update `maskUMI` and `maskCB` to handle zero bits without shifting by 64.
    - Add runtime assertions verifying `cbIdx` and `umiPacked` fit in their masks (e.g. `if (cbIdx > maskCB()) throw`).

6.2 Add unit tests in a new file `test/PackedReadInfo_test.cpp` (or existing test harness) covering pack/unpack, status updates, zero-UMI assays, and overflow guards.

Stage 7 – Build & Test
----------------------
7.1 Rebuild legacy path: `make clean && make STAR`.
7.2 Re-run the dataset used in Stage 0; keep outputs for comparison.
7.3 Rebuild with packed flag: `make clean && make STAR CXXFLAGS+=" -DSOLO_USE_PACKED_READINFO"`.
7.4 Repeat the run with identical inputs producing `packed.Aligned.out.bam` and new tag binaries.
7.5 Run comparison scripts:
    - `python new/scripts/verify_packed_vs_legacy.py legacy.Aligned.out.bam packed.Aligned.out.bam`
    - `python new/scripts/compare_tag_bin.py legacy.Solo.out/CB_tag.bin Solo.out/CB_tag.bin`
7.6 Execute unit tests: `ctest -R PackedReadInfo` (or equivalent command).
7.7 Measure memory: `/usr/bin/time -v ./STAR ...` for both builds and log `Max resident set size` in `DEBUG_RUN_STATUS.md`.

Stage 8 – Documentation & Cleanup
---------------------------------
8.1 Update `TECHNICAL_NOTES.md` with the snippet from Section 18 of `new/docs/packed_readinfo_design.md` after confirming behaviour.
8.2 Mark the relevant checkboxes in Section 16 of `new/docs/packed_readinfo_design.md`.
8.3 If tests pass, prepare a summary for code review (list files touched, tests run, memory delta).
8.4 Leave the repo in a clean state (`git status`) and package diffs for review.

Appendix – Useful Commands
--------------------------
- Search for remaining legacy accesses: `rg "readInfo" source | grep -v packed`.
- Inspect packed bits manually:
  ```bash
  python - <<'PY'
  from PackedReadInfo import PackedReadInfo # adjust import if binding exists
  # TODO: add quick smoke once bindings are ready
  PY
  ```

