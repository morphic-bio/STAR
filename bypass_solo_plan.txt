BYPASS SOLO PIPELINE PLAN (LOADER + SINKS)
==========================================

# Stage 0 – Setup & Baseline
0.1 Ensure branch is `feat/packed-readinfo-8byte` (or chosen workspace branch).
0.2 Verify clean build: `make clean && make STAR`.
0.3 Record baseline skip-mode behaviour (current memory usage/logs) for comparison.

# Stage 1 – Pre-Refactor Capture Harness
1.1 Add `test/SoloReadInfoBaseline_test.cpp` that:
     - Opens a representative Solo tmp file (fixture) or mocks `SoloReadFeature` stream.
     - Uses existing `SoloReadFeature::inputRecords` + `readInfo` path to count emitted records.
     - Logs counts via `std::cout` or asserts >0 to prove replay works.
1.2 Wire the baseline test into build (`source/Makefile`, `ctest`).
1.3 Run `ctest -R SoloReadInfoBaseline` to confirm the capture runs before refactor starts.

# Stage 2 – Design Loader Interface
2.1 Create `source/SoloReadInfoLoader.h/.cpp`:
     - Define `struct ReadInfoRecord { uint64_t readId; uint32_t cbIdx; uint32_t umi; uint8_t status; };`
     - Define `enum class SoloReadInfoMode { Minimal, Counting };`
     - Define `using RecordSink = std::function<void(const ReadInfoRecord&)>;`
     - Provide `class SoloReadInfoLoader { void load(SoloFeature&, SoloReadInfoMode mode, const RecordSink& sink); };`
2.2 Extract shared parsing code from `SoloReadFeature::inputRecords` into loader:
     - Loader handles stream positioning, WL lookups, CB match filtering.
     - Emits `ReadInfoRecord` per read, independent of downstream storage.
2.3 Unit test loader (`test/SoloReadInfoLoader_test.cpp`):
     - Mock sink collects records, assert counts & sample values match baseline from Stage 1.
     - Include error cases (e.g. invalid WL index) if easy.

# Stage 3 – Implement Sinks
3.1 Introduce `source/SoloReadInfoSink.h` interface with `onRecord`/`finalize` methods.
3.2 Implement `CountingSink` (`source/SoloReadInfoSinkCounting.cpp`):
     - Allocate `rGeneUMI`, `rCBp`, etc. in constructor (or via helper).
     - `onRecord` replicates legacy behaviour (fill triplets, maintain counters).
     - `finalize` calls `collapseUMIall()` and downstream steps.
     - Add focused unit test verifying `rGeneUMI` population and that `finalize` produces expected counts on small fixture.
3.3 Implement `MinimalSink` (`source/SoloReadInfoSinkMinimal.cpp`):
     - On each record call `SoloFeature::recordReadInfo`.
     - No large allocations; `finalize` is no-op.
     - Test ensures `PackedReadInfo` gets correct CB/UMI/status values.

# Stage 4 – Refactor Call Sites
4.1 Update `SoloFeature::countCBgeneUMI()`:
     - Replace manual `inputRecords` call + `collapseUMIall` with loader + `CountingSink`.
     - Ensure logging and stats remain intact.
     - Adjust lifetime of `rGeneUMI`, `rCBp` to reside inside sink.
4.2 Update `SoloFeature::prepareReadInfoOnly()`:
     - Call loader + `MinimalSink`.
     - Remove `rGeneUMI` allocations and `collapseUMIall(true)` call.
     - Confirm skip-mode log (`Allocated minimal arrays...`) no longer prints.
4.3 Verify `SoloFeature_processRecords.cpp` still routes skip mode through `prepareReadInfoOnly()` and counting mode through `countCBgeneUMI()`.
4.4 Run unit tests from Stages 1–3 to ensure refactor didn’t break behaviour.

# Stage 5 – Dual-Path Parity Test
5.1 Create `test/SoloReadInfoParity_test.cpp`:
     - Instantiate loader twice on same fixture: once with counting sink, once with minimal sink.
     - Capture outputs (e.g. build map of readId→(cb,umi,status) from both) and assert equality.
     - Hook into build/`ctest`.
5.2 Extend `new/tests/skip_processing_test.sh`:
     - Run STAR twice (full vs `--soloSkipProcessing yes`) with small dataset.
     - Use `new/scripts/verify_packed_vs_legacy.py` or similar parity script to compare CB/UB tags.
     - Optionally parse `Log.out` to confirm RSS reduction (no “Allocated minimal arrays…” in skip run).

# Stage 6 – Clean Up Legacy Hooks
6.1 Remove unused `SoloReadFeature::inputRecords` overload(s); keep private helper if needed for loader.
6.2 Delete `.bak` scaffolding files in `source/`.
6.3 Update `source/Makefile` object list for new files and tests.
6.4 Ensure `PackedReadInfo_test.cpp` still passes; adjust includes if necessary.

# Stage 7 – Documentation & Verification
7.1 Update `new/docs/packed_readinfo_design.md`:
     - Document loader/sink split in Section 3A.
     - Mark implementation checklist items complete.
7.2 Update `TECHNICAL_NOTES.md` with new architecture note.
7.3 Capture memory comparison numbers and note them in `DEBUG_RUN_STATUS.md`.
7.4 Run full build + tests:
     - `make clean && make STAR`
     - `ctest`
     - `new/tests/skip_processing_test.sh`
7.5 `git status`, stage changes, prepare summary for code review (highlight memory gains, parity tests).

