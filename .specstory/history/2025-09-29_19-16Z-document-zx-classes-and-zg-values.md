<!-- Generated by SpecStory -->

<!-- cursor Session dccbcb72-b407-4c7c-bd7d-3901763db968 (2025-09-29 19:16Z) -->

# Document ZX classes and ZG values (2025-09-29 19:16Z)

_**User (2025-09-29 18:41Z)**_

Looking at the docs/ZG_ZX_Implementation_SUmmary.md and the code inf necesary - can you tell me what each of the classes in ZX mean, and when you get a list, empty, and single value in ZG. Add this to the docmentation as well. Also note where the code is doing all this - i.e what internal STAR structures are used.

---

_**Assistant (gpt-5-high)**_

<think><details><summary>Thought Process</summary>**Documenting ZX and ZG behavior**

I need to read the implementation summary and code to find classes in the ZX module or package, as well as understand the behavior of ZG with lists. I should document these findings and note relevant code structures. To do this, I'll search the codebase for ZX and ZG classes and their semantics, focusing on parallel queries for efficiency. I have to maintain a TODO list to track steps like drafting document additions and cross-referencing code. I'll also provide updates during this process.
**Reconciling the todo list**

At the end, I need to reconcile the todo list and provide a summary. I'll follow the "citing_code" rules, meaning I must include specific line references when showing code. Small code snippets can help, but there’s a directive to avoid heavy formatting, so bullet points are fine. I also need to open the docs file to update it by applying patches, but first, I should read the contents and find the best place to add new information about ZX and ZG.
**Planning the tasks**

I should create some TODO items: first, discover the classes in ZX and their meanings; second, determine how ZG handles lists, empty states, and single value cases; third, locate the relevant code and internal STAR structures; fourth, update the documentation in `docs/ZG_ZX_Implementation_Summary.md`; and fifth, consider running lints, but I realize there are none for docs.  

To start, I’ll read the docs file to understand its content and how to integrate additions. Then, I’ll use a codebase search to find ZX class definitions and ZG semantics while possibly combining that with grep for precise strings. I'll also need to check the repo structure as it might involve various languages.
**Running the tools**

I want to start by running tools to get the directory structure using `list_dir /mnt/pikachu/STAR`. After that, I’ll use a codebase search with broad queries about ZX classes and ZG semantics.  

I also plan to use grep to search for instances of "\bZX\b" and "\bZG\b". Since I want to maximize efficiency, I’ll run the `list_dir` and grep queries in parallel, keeping in mind that the parallel tool only allows certain functions. Luckily, `list_dir` is included as a function tool, so I can run it alongside grep searches for both ZX and ZG throughout the repo. Furthermore, I need to run codebase search queries focused on defining ZX classes and the behaviors of ZG. Let’s get started!
**Preparing for tool execution**

I need to include a status update before making any tool calls. I'll execute multiple tools in parallel, specifically five: first, `list_dir`; then two grep searches for ZX and ZG; and finally, two codebase searches focused on ZX classes and ZG semantics. This structured approach should help me gather the necessary information efficiently. I’m ready to proceed with these tool calls now!</details></think>

---

I'll scan the repository to locate ZX/ZG definitions and usages, and open the summary doc to integrate precise descriptions and code references.

---

Tool use: **list_dir**

<details>
            <summary>Listed directory undefined • **0** results</summary>
        
No results found
</details>

---

Tool use: **grep**

---

Tool use: **grep**

---

Tool use: **codebase_search**

<details>
                <summary>Searched codebase "Where are ZX classes defined? What are ZX classes and their meanings?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `RELEASEnotes.md` | L38 |
| `source/ZGZXTags.h` | L20 |
| `docs/ZG_ZX_Implementation_Summary.md` | L31 |
| `README.md` | L53 |
| `source/ZGZXTags.cpp` | L52 |
| `runSTAR.sh` | L43 |
| `docs/ZG_ZX_Implementation_Summary.md` | L29-84 |
| `docs/ZG_ZX_Concordance_Analysis.md` | L44 |
| `validate_zg_zx.py` | L4-94 |
| `docs/ZG_ZX_Implementation_Summary.md` | L79-141 |
| `validate_zg_zx.py` | L94 |
| `source/SoloBarcode.h` | L37 |
| `docs/ZG_ZX_Concordance_Analysis.md` | L41-100 |
| `docs/gene_id_insertion_plan.txt` | L92-138 |
| `source/SoloFeatureTypes.h` | L11 |

</details>

---

Tool use: **codebase_search**

<details>
                <summary>Searched codebase "When does ZG return a list, an empty result, or a single value?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `validate_zg_zx.py` | L4-94 |
| `docs/ZG_ZX_Implementation_Summary.md` | L29-84 |
| `docs/ZG_ZX_Concordance_Analysis.md` | L41-100 |
| `analyze_concordance.py` | L7-111 |
| `source/ZGZXTags.cpp` | L52 |
| `docs/ZG_ZX_Concordance_Analysis.md` | L44 |
| `RELEASEnotes.md` | L38 |
| `analyze_concordance.py` | L7-114 |
| `validate_zg_zx.py` | L94 |
| `docs/ZG_ZX_Implementation_Summary.md` | L138-194 |
| `runSTAR.sh` | L43 |
| `validate_zg_zx.py` | L4-97 |
| `docs/ZG_ZX_Concordance_Analysis.md` | L98-149 |
| `docs/ZG_ZX_Implementation_Summary.md` | L79-141 |
| `docs/ZG_ZX_Implementation_Summary.md` | L31 |

</details>

---

<think><details><summary>Thought Process</summary>**Searching for overlap types**

I want to search for 'overlapTypes' within the `source`. My plan is to use grep to look through the `source/` directory for terms like 'ReadAnnotFeature' and 'overlapTypes'. That should help me find the relevant occurrences and understand how they're related. I suppose I need to be careful to check if the results are significant and relevant to what I'm exploring. Let's get started on this search!</details></think>

---

I'll locate the precise code that defines ZX classes and ZG formatting, including `ReadAnnotFeature` and `Transcriptome` structures, then update `docs/ZG_ZX_Implementation_Summary.md` with clear explanations and code references.

---

Tool use: **grep**

---

Tool use: **grep**

---

Tool use: **grep**

---

<think><details><summary>Thought Process</summary>**Searching for definitions**

I need to check `ReadAnnotations.h` for enumeration definitions. My grep results show references but not the actual enum itself; they could be defined in the `ReadAnnotFeature` class or elsewhere. The class shows fSet, fAlign, and ovType, but no enum definitions are visible. I'll search for "enum overlapTypes" or "overlapTypes::" to find the actual definition. Additionally, I need to determine when ZG yields list values. The function `ZGZXTags::formatZGTag` returns different outputs based on the size of fSet.
**Explaining overlap types**

The user likely wants to understand when different size conditions occur based on gene overlap detection in annotation features. In `Transcriptome_geneFullAlignOverlap.cpp`, the code sets `annFeat.fSet` with overlapping gene information and establishes `ovType`. Similarly, `Transcriptome_alignExonOverlap.cpp` determines `ovType` based on exonic and intronic features, using flags from `vGeneInfo`. 

If no genes overlap, `fSet` is empty, leading to a '-' output. If one gene overlaps, it produces a single gene ID, while multiple overlaps yield a comma-separated list. The user also asks about the meaning of each class in ZX, which ties back to enumerated overlap types, and I should clarify these semantics.
**Defining overlap types**

I need to clarify the meanings of various overlapTypes. In `Transcriptome_alignExonOverlap.cpp`, the `otFinal` array indexes refer to classifications like exonic, exonicAS, exonic50p, exonic50pAS, intronic, and intronicAS, which set `ovType` accordingly. I might need to consult additional documentation or relevant functions for full semantics.

For example, "exonic" indicates overlaps in exonic regions and treats antisense overlaps similarly. The "exonic50p" likely refers to overlaps where at least 50% of the feature is exonic. Each type has specific criteria, and the documentation may also confirm what internal structures, such as `ReadAnnotFeature`, are utilized to store this information.
**Updating documentation**

I need to cite line references and add details to the documentation. Specifically, I’ll update `docs/ZG_ZX_Implementation_Summary.md` to describe the mapping of ZX classes and ZG value cases, along with the relevant code references. I’ll employ the tools to edit this document. 

To do this, I’ll first read the entire file using `read_file` to ensure I have the full context for the patch. It's also possible that I might update `docs/ZG_ZX_Concordance_Analysis.md`, but the focus is on the Implementation Summary, as the user specified.
**Adding sections to documentation**

I’ll be updating the document with new sections. It's good that we've opened the document! I need to include status updates after any tool calls and mention the usage of a to-do list. This task has multiple steps: discovery, updating the document, and referencing code. 

I’m thinking of creating a small to-do list that includes gathering code details, drafting the new document section, inserting it, and verifying the linter usage. Since linting is not applied to the documents, I'll skip that part. I’ll use `multi_tool_use.parallel` for multiple reads, like grep, to find the enumeration definition for `ReadAnnotFeature::overlapTypes`. I should look for “enum overlap” in headers and see if it's located in `ReadAnnotations.h` or possibly other files.</details></think>

---

I'll locate the exact enum defining the ZX overlap classes and read the Implementation Summary doc to insert a concise section with meanings and ZG value cases, including code references to `ReadAnnotFeature` and `Transcriptome`.

---

Tool use: **grep**

---

<think><details><summary>Thought Process</summary>**Planning documentation updates**

I need to provide code references where tags are constructed in `ReadAlign_alignBAM.cpp`, specifically around lines that mention `ATTR_ZG` and strings. The documentation requires these references, and I must ensure not to include code dumps beyond what's necessary for citing. Since the user wants these added to the documentation, I'll modify the doc file accordingly and will use the `apply_patch` tool while being careful to preserve indentation and format. The doc is located at `/mnt/pikachu/STAR/docs/ZG_ZX_Implementation_Summary.md`, so I’ll read the contents fully to determine where to insert the new information.
**Updating documentation structure**

I need to identify the right sections to add in the Implementation Details, which has "Key Implementation Features" with ZG and ZX Tag bullet points. I'll include new subsections: 

First, "ZX Overlap Classes" with a table or bullet list detailing class definitions and mappings from `ReadAnnotFeature::overlapTypes` to ZX values along with internal code references. 

Second, "ZG Value Semantics" will include bullets like "Single gene," "Multi-gene list," and "Empty." 

I also need to note internal structures including `ReadAnnotFeature`, `Transcriptome`, and update any documentation mismatches regarding ZX valid values, specifically clarifying how 'intergenic' is mapped to 'none.' Lastly, I’ll consider the situation with `validate_zg_zx.py` since it lists 'intergenic' as an allowed value, even though the user didn't request code modifications.
**Finalizing documentation notes**

The doc update looks good! Since the user asked to "Add this to the documentation" instead of updating the script, I should leave the script as is and add a note that 'intergenic' normalizes to 'none' in the current implementation. I’ll also note what internal STAR structures are used and include relevant code references in the documentation. We can easily integrate these by using standard Markdown code fences. Although the "citing_code" instruction applies to messages, we can still format references appropriately in the documentation.
**Planning document updates and tasks**

I can include standard code snippet fences in the documentation, as long as I'm cautious. The instructions indicate that I shouldn't output code to the user; however, updating the documentation itself is not the same as outputting. It's fine to insert content with code references while ensuring the documentation remains clean. I’ll format file and class names in backticks and mention file paths and function names without including actual code. 

Next, for this multi-step task, I should use `todo_write`. I'll set up a two-step todo: 1) Extract semantics for ZX and ZG, and 2) Update the Implementation Summary doc with new sections.
**Managing task progress**

I'm planning to mark the first task as "in_progress" and then complete it. Next, I'll do the same for the second task, also marking it as "in_progress" before editing the file and running `read_lints`. I know that lints are for code, so they won’t apply to the documentation. I’ll update todo statuses accordingly and finalize everything. It's important to include status updates before using any tools, which I've already noted. Now, I’ll read the `Implementation_Summary.md` to embed the necessary changes.</details></think>

---

I'll add a concise section to `docs/ZG_ZX_Implementation_Summary.md` describing ZX classes and ZG list/empty/single semantics, with references to the STAR structures and emission points, then update the doc accordingly.

---

Tool use: **read_file**

Read file: /mnt/pikachu/STAR/docs/ZG_ZX_Implementation_Summary.md

---

<think><details><summary>Thought Process</summary>**Updating documentation details**

I need to respond to the user's request regarding the documentation for the classes in ZX and the ZG semantics. I should check both the provided document path and the code for relevant details. The document name has some capitalization oddities, but I see it's actually "ZG_ZX_Implementation_Summary.md." I’ll make sure to add sections regarding the meaning of ZX classes, when ZG yields list, empty, and single values, along with the internal STAR structures used. Then I'll update the document accordingly.
**Planning code and documentation updates**

I need to include code references in my response, as the developer guidelines specify. It’s important to use code edit tools for changes and run read_lints to check for linter errors — but that really only applies to code files, not documentation like markdown. I also have to manage a TODO list due to the medium-sized nature of this edit. The tasks include extracting ZX classes and ZG semantics, identifying internal STAR structures, and updating the documentation accordingly. I'll create a TODO list and make sure to include status updates before and after any tool calls.
**Preparing documentation edits**

I need to use multi_tool_use.parallel to run searches more efficiently. While I've done some grep and codebase_search, the user wants content added to the documentation. I’ve read the document before, and now I’ll prepare to edit it by adding new sections like "ZX Classes (Overlap Status) - definitions," "ZG Tag value cases," and "Internal Structures and Code Paths." I’ll include references to the `ReadAnnotations.h` class and various related functions across different files. Citations of code lines will go in my message, not the edits.
**Adding code references to documentation**

I want to incorporate code references in the document, either as file paths or cross-references. The user emphasized that I should note where the code performs certain functions, specifically which internal STAR structures are used. I can add text and snippets in the doc. According to the guidelines, when citing code, I should use CODE REFERENCES blocks with line numbers and file paths. Yes, I can include these references in the markdown. I'll use the functions.apply_patch tool to update the document accurately.
**Implementing documentation updates**

I need to read the file before patching and ensure I preserve the markdown indentation style. I’ll add new sections after "Key Implementation Features" or "Critical Design Decisions." The document currently has incomplete ZX "Valid Values" and ZG semantics. I want to clarify when ZG returns list, single, or empty values by adding a sub-section titled "Semantics and decision rules." I’ll also include definitions for ZX classes and ZG semantics, noting where the code sets overlapTypes and returns specific results. I'll create a TODO list for documenting ZX classes, ZG cases, and internal structures, marking tasks as in progress before applying all edits in one go!
**Organizing code references and emissions**

I want to clearly define the code references related to overlap types and emission points. The `overlapTypes` enum is found in `source/ReadAnnotations.h`, and `ovType` is set in various source files, like `Transcriptome_alignExonOverlap.cpp` for mapping. For ZG value semantics, I’ll detail what happens for empty, single, and list cases, referencing relevant functions and structures that handle gene indices. I’ll also mention the internal structures for clarity and ensure that the format preserves indentation and spacing. It’s time to create the patch!</details></think>

---

I'm going to update the Implementation Summary to include a concise section that defines each ZX overlap class, explains when ZG is a list vs empty vs single, and points to the STAR internal structures and files where this logic is implemented.

---

Tool use: **todo_write**

## Todo List

- [-] Document ZX overlap classes meanings in Implementation Summary
- [ ] Document ZG list/empty/single semantics in Implementation Summary
- [ ] Add internal structures and code locations section to Implementation Summary

---

I'll add the new sections to the doc, citing the exact enum and functions and explaining ZG value cases.

---

Tool use: **edit_file**


<details><summary>Edit file: /mnt/pikachu/STAR/docs/ZG_ZX_Implementation_Summary.md</summary>

**Chunk 1**
Lines added: 110, lines removed: undefined

```diff
@@ -44,4 +44,114 @@
  - **Source**: Uses `ReadAnnotFeature::ovType` from genomic overlap analysis
  - **Function**: `ZGZXTags::formatZXTag()`
+ 
+ ### ZX Classes: Meanings and Mapping to Internal Enums
+ 
+ The ZX tag summarizes genomic overlap for each read, derived from `ReadAnnotFeature::ovType`.
+ 
+ - **exonic**: Read overlaps exons. Includes antisense and ≥50% exonic cases. Internally, these enums map to `exonic`, `exonicAS`, `exonic50p`, `exonic50pAS` and are all emitted as `exonic`.
+ - **intronic**: Read overlaps introns. Includes antisense intronic (`intronic`, `intronicAS`).
+ - **none**: No gene overlap, i.e. intergenic. `intergenic` and `none` collapse to `none`.
+ - **spanning**: Fallback for unknown/other types.
+ 
+ Code references:
+ ```12:18:source/ReadAnnotations.h
+ class ReadAnnotFeature {//annotations for one feature
+ public:
+     set<uint32> fSet;  //set of genes for this read
+     vector<set<uint32>> fAlign; //gene for each alignment of this read
+     uint32 ovType;
+     enum overlapTypes {none, exonic, exonicAS, exonic50p, exonic50pAS, intronic, intronicAS, intergenic, N};
+ ```
+ 
+ ```32:53:source/ZGZXTags.cpp
+ const char* ZGZXTags::overlapTypeToString(uint32 ovType) {
+     switch (ovType) {
+         case ReadAnnotFeature::overlapTypes::none:            return "none";
+         case ReadAnnotFeature::overlapTypes::exonic:          return "exonic";
+         case ReadAnnotFeature::overlapTypes::exonicAS:        return "exonic";  
+         case ReadAnnotFeature::overlapTypes::exonic50p:       return "exonic";  
+         case ReadAnnotFeature::overlapTypes::exonic50pAS:     return "exonic";  
+         case ReadAnnotFeature::overlapTypes::intronic:        return "intronic";
+         case ReadAnnotFeature::overlapTypes::intronicAS:      return "intronic"; 
+         case ReadAnnotFeature::overlapTypes::intergenic:      return "none"; 
+         default:                                              return "spanning";
+     }
+ }
+ ```
+ 
+ ```200:215:source/Transcriptome_alignExonOverlap.cpp
+         if (otFinal[0]) {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::exonic;
+         } else if (otFinal[1]) {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::exonicAS;
+         } else if (otFinal[2]) {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::exonic50p;
+         } else if (otFinal[3]) {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::exonic50pAS;
+         } else if (otFinal[4]) {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::intronic;
+         } else if (otFinal[5]) {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::intronicAS;
+         } else {
+             annFeat.ovType = ReadAnnotFeature::overlapTypes::intergenic; // intergenic
+         };
+ ```
+ 
+ ### ZG Values: When You Get List, Empty, or Single
+ 
+ ZG reports the set of overlapping genes using Ensembl IDs from the loaded `Transcriptome`.
+ 
+ - **Single value**: One overlapping gene detected.
+ - **List (comma-separated)**: Multiple overlapping genes for the read.
+ - **Empty (`-`)**: No overlapping genes detected.
+ 
+ Code references:
+ ```5:26:source/ZGZXTags.cpp
+ string ZGZXTags::formatZGTag(const ReadAnnotFeature &annFeat, const Transcriptome &transcriptome) {
+     if (annFeat.fSet.empty()) {
+         return "-";
+     }
+     string result;
+     bool first = true;
+     for (uint32 geneIdx : annFeat.fSet) {
+         if (!first) { result += ","; }
+         if (geneIdx < transcriptome.geID.size()) {
+             result += transcriptome.geID[geneIdx];
+         } else {
+             result += "UNKNOWN_GENE_" + to_string(geneIdx);
+         }
+         first = false;
+     }
+     return result;
+ }
+ ```
+ 
+ - `annFeat.fSet` is populated by GeneFull overlap logic and enumerates gene indices; these map to gene IDs via `Transcriptome::geID`.
+ 
+ ```17:19:source/Transcriptome.h
+ vector <string> trID, geID, geName, geBiotype; //transcript/gene IDs
+ ```
+ 
+ ```24:33:source/Transcriptome_geneFullAlignOverlap.cpp
+ Transcriptome::geneFullAlignOverlap(..., ReadAnnotFeature &annFeat)
+     ...
+     annFeat.fSet.insert(geneFull.g[gi1]);
+     annFeat.fAlign[iA].insert(geneFull.g[gi1]);
+ ```
+ 
+ ### Where Tags Are Emitted
+ 
+ ZG/ZX are emitted during BAM writing using the `GeneFull` feature annotations:
+ 
+ ```447:459:source/ReadAlign_alignBAM.cpp
+ // ZG tag
+ string zgTag = ZGZXTags::formatZGTag(readAnnot.annotFeatures[SoloFeatureTypes::GeneFull], *chunkTr);
+ attrN+=bamAttrArrayWrite(zgTag, "ZG", attrOutArray+attrN);
+ // ZX tag
+ string zxTag = ZGZXTags::formatZXTag(readAnnot.annotFeatures[SoloFeatureTypes::GeneFull]);
+ attrN+=bamAttrArrayWrite(zxTag, "ZX", attrOutArray+attrN);
+ ```
+ 
+ This uses the `ReadAnnotFeature` computed by GeneFull and the `Transcriptome` gene IDs to serialize tags.
  
  ### Critical Design Decisions
```

</details>

---

I added the ZX class meanings, ZG value cases, and precise code references to the Implementation Summary. I’ll mark the ZX doc task complete and proceed to document ZG semantics and code refs as completed too since they were included in the same edit.

---

Tool use: **todo_write**

## Todo List

- [x] Document ZX overlap classes meanings in Implementation Summary
- [x] Document ZG list/empty/single semantics in Implementation Summary
- [x] Add internal structures and code locations section to Implementation Summary

---

- I found and formalized the ZX classes from `ReadAnnotFeature::overlapTypes` and how they collapse to ZX values via `ZGZXTags::overlapTypeToString`.
- I documented when ZG is a list, empty, or single value, and linked those behaviors to `annFeat.fSet` population and `Transcriptome::geID` lookup.
- I added code references that show exactly where tags are computed and emitted.

Key additions in `docs/ZG_ZX_Implementation_Summary.md`:
- ZX class meanings and mapping to internal enums with code references to `source/ReadAnnotations.h`, `source/ZGZXTags.cpp`, `source/Transcriptome_alignExonOverlap.cpp`.
- ZG value cases (single/list/empty) tied to `annFeat.fSet` and `Transcriptome::geID`, with references to `source/ZGZXTags.cpp`, `source/Transcriptome.h`, `source/Transcriptome_geneFullAlignOverlap.cpp`.
- Emission points citing `source/ReadAlign_alignBAM.cpp` for `ZGZXTags::formatZGTag` and `formatZXTag`.

If you want, I can mirror a concise summary of these points in `docs/ZG_ZX_Concordance_Analysis.md` too.

---

